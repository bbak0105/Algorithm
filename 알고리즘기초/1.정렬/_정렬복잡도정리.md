|알고리즘|시간복잡도(최선)|시간복잡도(평균)|시간복잡도(최악)|공간복잡도|정렬종류|etc|
|---|---|---|---|---|---|---|
|버블정렬|O(n)|O(n²)|O(n²)|O(1)|안정|시간❌ 공간✅|
|선택정렬|O(n²)|O(n²)|O(n²)|O(1)|불안정|시간❌ 공간✅|
|삽입정렬|O(n)|O(n²)|O(n²)|O(1)|안정|시간❌ 공간✅|
|합병정렬|O(n log n)|O(n log n)|O(n log n)|O(n log n)|안정|시간✅ 공간❌|
|퀵정렬|O(n log n)|O(n log n)|O(n²)|O(n log n)|불안정|이미 정렬된 배열에서 좋지 못함❌|
|힙정렬|O(n log n)|O(n log n)|O(n log n)|O(n) 또는 O(1)|불안정|최댓값 최솟값 찾기 좋음✅|
|기수정렬|O(kn)|O(kn)|O(kn)|O(n)|안정|실수 불가능❌ 자리수 적은 정수에 좋음✅|
|내장정렬|O(n log n)|O(n log n)|O(n log n)|O(n log n)|안정|효율이 좋음✅|

*k는 자리수의 개수 

<br/>

❗️버블정렬, 선택정렬, 삽입정렬은 모두 시간 복잡도(최악)이 가장 좋지 않다.

❗️합병정렬, 퀵정렬은 공간 복잡도가 좋지 않다. (재귀를 쓰기 떄문에)

❗️합병정렬과 퀵정렬을 비교하면 시간복잡도(최악)의 경우 합병정렬이 더 좋다.

❗️힙정렬은 최대, 최소문제의 경우 가장 좋지만 안정 정렬이 필요한 상황이라면 좋지 않다.

(동일한 값이 여러개 있는 경우 순서가 유지되기 어려우므로)

❗️내장정렬은 호출되는 환경마다 조금씩 복잡도가 다르다. FireFox의 경우 합병정렬을 사용하고 Chrome V8의 경우 합병과 삽입 정렬의 하이브리드 버전인 Tim sort를 쓴다.
